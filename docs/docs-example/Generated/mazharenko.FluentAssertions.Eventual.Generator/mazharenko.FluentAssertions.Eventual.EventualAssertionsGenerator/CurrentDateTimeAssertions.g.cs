// <auto-generated />
using System;
using FluentAssertions;
using FluentAssertions.Execution;
using mazharenko.FluentAssertions.Eventual;

namespace docs_example
{
	[System.CodeDom.Compiler.GeneratedCodeAttribute("mazharenko.FluentAssertions.Eventual", "4.0.2")]
	public static class CurrentDateTimeAssertions_Eventual_Extensions
	{
		public static CurrentDateTimeAssertions_Eventual Eventually(this CurrentDateTimeAssertions underlying)
		{
			return Eventually(underlying, System.TimeSpan.FromSeconds(5), System.TimeSpan.FromMilliseconds(100));
		}

		public static CurrentDateTimeAssertions_Eventual EventuallyLong(this CurrentDateTimeAssertions underlying)
		{
			return Eventually(underlying, System.TimeSpan.FromSeconds(20), System.TimeSpan.FromMilliseconds(500));
		}

		public static CurrentDateTimeAssertions_Eventual Eventually(this CurrentDateTimeAssertions underlying, System.TimeSpan timeout, System.TimeSpan delay)
		{
			return new CurrentDateTimeAssertions_Eventual(underlying, timeout, delay);
		}
	}

	[System.CodeDom.Compiler.GeneratedCodeAttribute("mazharenko.FluentAssertions.Eventual", "4.0.2")]
	public class CurrentDateTimeAssertions_Eventual
	{
		private readonly CurrentDateTimeAssertions underlying;
		private readonly System.TimeSpan timeout;
		private readonly System.TimeSpan delay;
		public CurrentDateTimeAssertions_Eventual(CurrentDateTimeAssertions underlying, System.TimeSpan timeout, System.TimeSpan delay)
		{
			this.underlying = underlying;
			this.timeout = timeout;
			this.delay = delay;
		}

		[CustomAssertion]
		public AndConstraint<CurrentDateTimeAssertions> BeAfter(DateTime expected, string? because = null, params object[] becauseArgs)
		{
			AndConstraint<CurrentDateTimeAssertions> result = default;
			foreach (var _  in EventualAssertions.Attempts(timeout, delay))
				result = underlying.BeAfter(expected, because, becauseArgs);
			return result;
		}
	}
}